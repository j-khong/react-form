import * as React from 'react';
import { Fields } from './Field';

export class Form extends React.Component<FormProps, FormState> {
    constructor(props: FormProps) {
       super(props);
 
       const errors: Errors = {};
       const values: Values = {};
       this.state = {
          errors,
          values,
       };
    }
 
    public render() {
       const { submitSuccess, errors } = this.state;
       const context: FormContext = {
          ...this.state,
          setValues: this.setValues,
          validate: this.validate,
       };
 
       return (
          <TheFormContext.Provider value={context}>
             <form onSubmit={this.handleSubmit} noValidate={true}>
                <div className="container">
                   {this.props.render ? this.props.render() : this.renderFields()}
 
                   <div className="form-group">
                      <button type="submit" className="btn btn-primary" disabled={this.haveErrors(errors)}>
                         Submit
                      </button>
                   </div>
                   {submitSuccess && this.getSubmissionSuccessElement()}
                   {submitSuccess === false && !this.haveErrors(errors) && this.getSubmissionFailElement()}
                   {submitSuccess === false && this.haveErrors(errors) && this.getFieldValidationFailElement()}
                </div>
             </form>
          </TheFormContext.Provider>
       );
    }
 
    private handleSubmit = async (e: React.FormEvent<HTMLFormElement>): Promise<void> => {
       e.preventDefault();
 
       console.log(this.state.values);
 
       if (await this.validateForm()) {
          console.log('validation ok');
          const submitSuccess: boolean = await this.props.submit(this.state.values);
          this.setState({ submitSuccess });
       } else {
          console.log('validation failed');
       }
    };
 
    private haveErrors(errors: Errors) :boolean{
       for( const key of Object.keys(errors)){
         if (errors[key].length > 0) {
             return true;
          }
       }
       
       return false;
    }
 
    private setValues = (values: Values) => {
       this.setState({ values: { ...this.state.values, ...values } });
    };
 
    private async validateForm(): Promise<boolean> {
       const errors: Errors = {};
       for (const fieldName in this.props.fields) {
          errors[fieldName] = await this.validate(fieldName);
       }
       this.setState({ errors });
       return !this.haveErrors(errors);
    }
 
    private validate = async (fieldName: string): Promise<string> => {
       let newError: string[] = [];
 
       console.log('validating ', fieldName)
       if (this.props.fields[fieldName]) {
          for (const validation of this.props.fields[fieldName].data.validations) {
             const res = await validation.check(this.state.values[fieldName]);
             !res.validated && newError.push(res.message);
          }
       }
       const errors = newError.join(', ');
       this.state.errors[fieldName] = errors;
       this.setState({
          errors: { ...this.state.errors, [fieldName]: errors },
       });
       return errors;
    };
 
    private renderFields = () => {
       return (
          <React.Fragment>
             {Object.keys(this.props.fields).map((fieldName: string) =>
                this.props.fields[fieldName].render({ ...this.props.fields[fieldName].data }),
             )}
          </React.Fragment>
       );
    };
 
    protected getSubmissionSuccessElement() {
       return (
          <div className="alert alert-info" role="alert">
             The form was successfully submitted!
          </div>
       );
    }
    protected getSubmissionFailElement() {
       return (
          <div className="alert alert-danger" role="alert">
             Sorry, an unexpected error has occurred
          </div>
       );
    }
 
    protected getFieldValidationFailElement() {
       return (
          <div className="alert alert-danger" role="alert">
             Sorry, the form is invalid. Please review, adjust and try again
          </div>
       );
    }
 }


interface FormProps {
   // The props for all the fields on the form
   fields: Fields;
   
   submit: (v: Values) => Promise<boolean>;

   // the form is autogenerated, but with a provided render function, you can customise render
   render?: () => React.ReactNode;
}

export interface Values {
   // Key value pairs for all the field values
   [key: string]: any;
}

interface FormState {
   values: Values;
   errors: Errors;
   submitSuccess?: boolean;
}

export interface Errors {
   [key: string]: string;
}

export interface FormContext extends FormState {
   setValues: (values: Values) => void;

   validate: (fieldName: string) => void;
}

export const TheFormContext = React.createContext<FormContext | undefined>(undefined);
